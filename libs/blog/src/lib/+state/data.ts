export const testPostContent = `
# JWT Auth in Lucky Api

To start we'll be using the lucky api demo app which has \`User\` and \`Post\` models defined. Run \`git clone git@github.com:mikeeus/lucky_api_demo.git\` and \`checkout blog-starter\`.

## Dependencies

The only dependecy we'll need is a shard for jwt encoding and decoding. We can use [the crystal jwt package](https://github.com/crystal-community/jwt) so lets add the following to our shard.yml and run \`shards\`.
\`\`\`
dependencies:
  jwt:
    github: crystal-community/jwt
\`\`\`

## Begin with Tests

How else would we know the app is working? Aight, in \`spec/blog_api_spec.cr\` we'll add a describe block for authentication and our first test which will be for signing in.

**Note** I got \`AppVisitor\` from [Hannes Kaeufler's blog](https://github.com/hanneskaeufler/blog) which is a great Lucky site that I use as reference.

\`\`\`crystal
# spec/blog_api_spec.cr
require "./spec_helper"

describe App do
  visitor = AppVisitor.new
  ...
  describe "auth" do
    it "signs in valid user" do
      # create a user
      
      # visit sign in endpoint
      
      # check response has status: 200 and authorization header with "Bearer"
    end
  end
end
\`\`\`

We'll user Lucky's boxes to make generating test data easy. We'll also use Authentic's \`generate_encrypted_password\` method to generate our password.

\`\`\`crystal
# spec/support/boxes/user_box.cr
class UserBox < LuckyRecord::Box
  def initialize
    name "Mikias"
    email "hello@mikias.net"
    encrypted_password Authentic.generate_encrypted_password("password")
  end
end
\`\`\`

Now we can generate a user in our test and make a post request to our sign_in endpoint using its email and password. And we'll check the response for the correct status code and Authorization header.

\`\`\`crystal
# spec/blog_api_spec.cr
...
    it "signs in valid user" do
      # create a user
      user = UserBox.new.create
      
      # visit sign in endpoint
      visitor.post("/auth/sign_in", ({
        "sign_in:email": user.email,
        "sign_in:password": "password"
      }))
      
      # check response has status: 200 and authorization header with "Bearer"
      visitor.response.status_code.should eq 200
      visitor.response.headers["Authorization"].should_not be_nil
    end
...
\`\`\`

Now this test will fail because we don't have an action for this route or the forms to handle user creation, so let's build them.

## Actions and Forms

If we generate a normal Lucky app it will come with [Authentic](https://github.com/luckyframework/authentic) already configured and several forms and actions will be generated for us. Currently, Lucky api configures \`Authentic\` but doesn't generate these files so we'll need to add them ourselves and update them to fit our use case.

### Actions

Let's start with the \`SignInForm\` which will be used to validate the user credentials, generate a token and return it in the \`Authorization\` header of the response. This form will be the same as the one generated by \`Authentic\` in new non-api apps, and we'll also need to create the form mixin \`FindAuthenticable\` which wasn't generated.

\`\`\`crystal
# src/forms/mixins/find_authenticable.cr
module FindAuthenticatable
  private def find_authenticatable
    email.value.try do |value|
      UserQuery.new.email(value).first?
    end
  end
end

# src/forms/sign_in_form.cr
class SignInForm < LuckyRecord::VirtualForm
  include Authentic::FormHelpers
  include FindAuthenticatable

  virtual email : String
  virtual password : String

  private def validate(user : User?)
    if user
      unless Authentic.correct_password?(user, password.value.to_s)
        password.add_error "is wrong"
      end
    else
      email.add_error "is not in our system"
    end
  end
end
\`\`\`

I'm going to put our \`SignIn\` and \`SignUp\` actions under an \`Auth\` namespace because of personal preference, but you can choose something else like \`SignUps::Create\`. Run \`lucky gen.action.api Auth::SignIn\` and use the SignInForm to find the user and generate the token.

We'll also add a \`generate_token\` method to our \`User\` model because we'll use it in our \`Auth::SignIn\` and \`Auth::SignUp\` actions as well as our \`AuthenticatedAction\` class later on.

\`\`\`crystal
# src/models/user.cr
require "jwt"

class User < BaseModel
  ...

  def generate_token
    exp = Time.now.epoch + 60 * 60 * 24 * 14
    user = ({ id: id, name: name, email: email }).to_s
    payload = { "sub" => id, "user" => Base64.encode(user), "exp" => exp }

    JWT.encode(payload, Lucky::Server.settings.secret_key_base, "HS256")
  end
end


# src/actions/auth/sign_in.cr
class Auth::SignIn < ApiAction
  post "/auth/sign_in" do # define route since the action doesn't follow Lucky's naming convention
    SignInForm.new(params).submit do |form, user|
      if user
        context.response.headers.add "Authorization", user.generate_token
        head 200
      else
        head 401
      end
    end
  end
end
\`\`\`

Now run \`crystal spec\` to see our tests pass!

We can follow the same workflow for the sign up feature. Lets write the test:

\`\`\`crystal
describe App do
  ...
    it "creates user on sign up" do
      visitor.post("/auth/sign_up", ({
        "sign_up:name" => "New User",
        "sign_up:email" => "test@email.com",
        "sign_up:password" => "password",
        "sign_up:password_confirmation" => "password"
      }))

      visitor.response.status_code.should eq 200
      visitor.response.headers["Authorization"].should_not be_nil

      UserQuery.new.email("test@email.com").first.should_not be_nil
    end
  ...
end
\`\`\`

We need to add a \`password_validations\` mixin and the \`SignUpForm\`. Although we should be doing password validations on the client, we'll also validate password length and confirmation on the server to be safe.

\`\`\`crystal
# src/forms/mixins/password_validations.cr
module PasswordValidations
  private def run_password_validations
    validate_required password, password_confirmation
    validate_confirmation_of password, with: password_confirmation
    validate_size_of password, min: 6
  end
end

# src/forms/sign_up_form.cr
class SignUpForm < User::BaseForm
  include PasswordValidations

  fillable email
  virtual password : String
  virtual password_confirmation : String

  def prepare
    validate_uniqueness_of email
    run_password_validations
    Authentic.copy_and_encrypt password, to: encrypted_password
  end
end
\`\`\`

Next we can use this form to fill out our action.

\`\`\`crystal
# src/actions/auth/sign_up.cr
class Auth::SignUp < ApiAction
  post "/auth/sign_up" do
    SignUpForm.create(params) do |form, user|
      if user
        context.response.header.add "Authorization", user.generate_token
        head 200
      else
        head 401
      end
    end
  end
end
\`\`\`

And voila! Run \`crystal spec\` to see the beautiful green output. Now we can sign up and sign in but what about protecting routes?

## Protect Routes with AuthenticatedAction

First lets update our tests to make sure this feature works as expected.

\`\`\`crystal
describe App do
  ...
    it "creates post" do
      user = UserBox.create
      token = user.generate_token

      visitor.post("/posts", new_post_data, { "Authorization" => token })

      visitor.response_body["title"].should eq new_post_data["post:title"]
    end

    it "rejects unauthenticated requests to protected actions" do
      visitor.post("/posts", new_post_data)
      visitor.response.status_code.should eq 401
    end
  ...
end

def new_post_data
  ({
    "post:title" => "New Post",
    "post:content" => "Probably the best post you've ever read",
    "post:published_at" => Time.now.to_s,
    "post:tags" => "dope, informative",
    "post:comment_id" => "1"
  })
end
\`\`\`

Protecting routes by requiring authentication is straight forward since our actions inherit from \`LuckyAction\`. What we'll do is create a new \`AuthenticatedAction\` that checks for an \`Authorization\` header for a token, checks the expiry and sets the current_user if all checks out.

We use the \`before\` callback to call \`require_current_user\` before the action runs. We'll also create a new method on \`UserQuery\` to parse the token and fetch the user.

\`\`\`crystal
# src/queries/user_query.cr
class UserQuery < User::BaseQuery
  def from_token_payload(payload)
    find(payload["sub"].to_s)
  end

  def from_token(token : String)
    payload, _header = JWT.decode(token, Lucky::Server.settings.secret_key_base, "HS256")
    from_token_payload(payload)
  end
end

# src/actions/authenticated_action.cr
abstract class AuthenticatedAction < Lucky::Action
  before require_current_user

  # @current_user will be available in our routes
  getter current_user : User? = nil
  
  private def require_current_user
    token = context.request.headers["Authorization"]?

    if token.nil?
      head 401
    else
      @current_user = UserQuery.new.from_token(token)
    end

    if @current_user.nil?
      head 401
    else
      continue
    end

  # UserQuery.new.from_token will raise this error if the token is expired
  rescue JWT::ExpiredSignatureError
    head 401
  end
end
\`\`\`

Now we can use this to protect our \`Posts::Create\` action.

\`\`\`crystal
# src/actions/posts/create.cr
class Posts::Create < AuthenticatedAction # inherit from AuthenticatedAction
  route do
    post = PostForm.create!(params, author: @current_user.not_nil!) # @current_user is now available
    json Posts::ShowSerializer.new(post), Status::Created
  end
end
\`\`\`
Run those specs and... BOOM! Protected. That's whats up.

## Join Us

I hope you found this tutorial useful. Join us on the [Lucky gitter channel](https://gitter.im/luckyframework/Lobby) to stay up to date on the framework or [checkout the docs](https://luckyframework.org/guides) for more information on how to bring your app idea to life with Lucky.
`
